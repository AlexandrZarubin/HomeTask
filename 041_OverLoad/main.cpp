// OverLoad
#include <iostream>
#include <windows.h>
#include <stdlib.h>

using namespace std;

//класс описывающий точку
class Point
{
    int X, Y;
public:
    //конструктор с параметрами со значением параметров по умолчанию
    Point(int x = 0, int y = 0)    //P(13,7)  P(15)  P(15,0)   P  P(0,0)
    {
        SetPoint(x, y); //вызов метода внутри конструктора
    }
    Point(int) = delete; //удалените конструктора для ситуации Point P(15);
    //Метод изменения координат точки
    void SetPoint(int x, int y) //сеттер
    {
        X = x;
        Y = y;
    }
    //метод вывода точки на экран
    void Show()const //геттер
    {
        cout << "(" << X << ";" << Y << ")" << endl;
    }
    //перегрузка операторов в качестве метода класса
    //перегрузка оператора сложения для ситуации Point + Point
    //Point operator+ (const Point& P)const //может быть const, так как не меняет содержимое текущего объекта this
    Point operator+ (const Point& P) //Point operator+ (const Point* this, const Point& P) this+P
    {
        //Point temp(this->X, this->Y); //значеием полей текущего объекта
        Point temp(X, Y); //создаем временный объект - результат работы оператора,
        //помещаем в него значения текущего объекта this

        //прибаляем к нему значение полей второго объекта
        temp.X += P.X;
        temp.Y += P.Y;
        return temp; //возвращаем значение временного объекта temp - результата работы оператора
    }
    //перегрузка префиксной формы оператора инкремент ++ для ситуации ++A
    Point& operator++()  // Point& operator++(const Point* this)
    {
        //увеличение содержимого всех полей текущего объекта в раза
        X *= 2; //X++;  //аналогично this->X *= 2;
        Y *= 2; //Y++;
        return *this; //возвращаем ссылку на текущий объект, разыменовывая указтель this
    }
    //перегрузка постфиксной формы оператора инкремент ++ для ситуации A++
    Point operator++(int)
    {
        Point temp(X, Y); //создаем копию текущего объекта
        //увеличение содержимого всех полей текущего объекта на 2
        X += 2; //X *= 2; 
        Y += 2; //this->Y *= 2;
        //++(*this); //вызов перегруженной префиксной формы оператора инкремент 
        return temp; //возвращаем предыдущее состояние текущего объекта
    }
    //перегрузка оператора вызова функции ()
    void operator() (int x, int y) //оператор будет задовать новые значения полям объекта
    {
        X = x;
        Y = y;
    }

    //перегрузка оператора вычитание, как метода класса для Point - int
    Point operator-(int A) //Point operator-(const Point* this, int A) this - A
    {
        //Point temp(this->X, this->Y);
        Point temp(X, Y); //значение полей, передаются по именам, так как в методе есть указатель this

        //уменьшаем значения обоих полей временного объекта на значение переменной А типа данных int
        temp.X -= A; //прямой доступ к полям объекта, так как перегружаем оператор как метод(член класса)
        temp.Y -= A;
        return temp; //возвращаем итоговый результат
    }

    //дружественная перегрузка оператора вычитание, для ситуации int-Point
    friend Point operator-(int A, const Point& P);

    //методы для доступа к private полям для глобальной перегрузки
    //геттеры
    int GetX()const { return X; }
    int GetY()const { return Y; }
    //сеттеры
    void SetX(int x) { X = x; }
    void SetY(int y) { Y = y; }

};

//глобальная перегрузка оператора + для ситуации int + Point
Point operator+(int A, const Point& P)
{
    //I вариант отдельный сеттер для каждого поля
    Point temp;
    temp.SetX(A + P.GetX()); //помещаем в поле X временного объекта temp, с помощью метода SetX сумму значений
    //переменной А типа данных int и поля Х объекта P(полученное с помощью метода GetX)
    temp.SetY(A + P.GetY());
    return temp;  //возвращаем итоговый результат

    //II вариант один сеттер для всех полей
    //Point temp; 
    //temp.SetPoint(A + P.GetX(), A + P.GetY());
    //return temp;
}

int main()
{
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);

    /*
    Нельзя перегружать операторы:
        ?:          тернарный оператор (A>B)?A:B;
        ::          доступа ко вложенным именам(расширения области видимости, принадлежности)
        .           доступа к полю по имени объекта
        .*          доступа к полю по имени объекта с разыменованием
        sizeof()    оператор определения размера

    Только в виде методов конкретного класса:
        =           присваивания
        ->          доступа к полю по адресу объекта(через указатель на объект) Селектор
        ()          оператор вызова функции
        []          доступа по индексу(индексирования)
        ->*         доступа к полю по адресу объекта(через указатель на объект) с разыменованием

    Нельзя перегрузить как метод конкретного класса:
        <<          оператор вывода
        >>          оператор ввода
    */

    /*
    Point A(3, 3);
    A.Show();
    cout << endl;
    Point B;
    B.Show();
    B.SetPoint(5, 5);
    B.Show();

    Point C = A + B;
    cout<< "Точка С: " << endl;
    C.Show();

    Point D = A + B + C;
    cout << "Точка D: " << endl;
    D.Show();

    A = D;
    cout << "Точка A: " << endl;
    A.Show();

    ++A;
    cout << "Точка A: " << endl;
    A.Show();
    A++;
    cout << "Точка A: " << endl;
    A.Show();
    system("cls");

    cout << "Точка B: " << endl;
    B.Show();

    Point E = B++; //постфиксная форма оператора инкремент. Сначала объекту Е будет присвоено текущее значение объекта В,
    //потом значение объекта B будет увеличено
    cout << "Точка B: " << endl;
    B.Show();
    cout << "Точка E: " << endl;
    E.Show();

    C = ++B; //префиксная ворма оператора инкремент. Сначала значение объекта B будет увеличено, потом
    //новое значение будет присвоено объекту C
    cout << "Точка B: " << endl;
    B.Show();
    cout << "Точка C: " << endl;
    C.Show();

    system("cls");

    A++; //краткая запись вызова постфиксной формы оператора инкремент
    ++A; //краткая запись вызова префиксной формы оператора инкремент

    A.operator++();     //полная запись вызова префиксной формы оператора инкремент
    A.operator++(0);    //полная запись вызова постфиксной формы оператора инкремент

    D = A + B; //краткая форма вызова перегруженного оператор сложение
    D = A.operator+(B); //полная форма вызова перегруженного оператора сложение
    //D = A.summa(B);
    //A.SetPoint(1, 1);
    system("cls");

    //изменение значений полей объекта
    A.SetPoint(10, 10); //с помощью метода сеттера
    cout << "Точка A: " << endl;
    A.Show();
    A(20, 20); //с помощью перегруженного оператора ()
    cout << "Точка A: " << endl;
    A.Show();
    A.operator()(30, 30); //полная запись вызова перегруженного оператора ()
    cout << "Точка A: " << endl;
    A.Show();
    */

    Point Z(10, 10);
    Point W = Z - 3;
    cout << "Точка W";
    W.Show();

    Point X = 50 - W;
    cout << "Точка X";
    X.Show();

    Z = 10 + X;
    cout << "Точка Z";
    Z.Show();

    //Z = X + 10;  //для такой операции нужна перегрузка Point+int
    cout << "Точка Z";
    Z.Show();

    Point T;
    cout << "Точка T";
    T.Show();
}

//реализация дружественной перегрузки оператора вычитание, для ситуации int-Point
Point operator-(int A, const Point& P) //для работы с объектом класса Point его нужно передавать в качестве аргумена в функцию
{
    //в дружественной перегрузке можно обращаться к private полям объекта класса, но только через переданный явно в
    //агрумент функции по ссылке объект класса

    Point temp(P.X, P.Y); //доступ к полям объекта через имя объекта, переданного в качестве аргумента 
    temp.X = A - temp.X;
    temp.Y = A - temp.Y;
    return temp; //возвращаем итоговый результат
}
