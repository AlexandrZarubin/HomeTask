// QuickSort_R
#include <iostream>
#include <stdlib.h>
#include <time.h>

using namespace std;
//прототип шаблона функции "Быстрая сортировка"
template<typename T, typename L> void QuickSort_R(T[], L, bool = true);
//прототип шаблона функции "Двоичный(Бинарный) поиск"
template<typename T, typename L> L BinarySearch(T[], L, T, bool = true);

int main()
{
	system("chcp 1251");
	system("cls");
	srand((unsigned int)time(NULL));
	cout << "---Программа сортировки массива!---" << endl;
	const int Size = 14;
	int Array[Size]{};
	bool Type = true;
	for (int i = 0; i < Size; i++)
	{
		Array[i] = rand() % (100 - (-99)) - 99;
		cout << Array[i] << " ";
	}
	cout << R"(
Выберите как отсортировать массив:
1 - от меньшего к большему(по возрастанию значений)
0 - от большего к меньшему(по убыванию значений)
)";
	cin >> Type;
	//вызов сортировки
	QuickSort_R(Array, Size, Type);
	//вывод отсортированного массива на экран
	for (int i = 0; i < Size; i++)
	{
		cout << Array[i] << " ";
	}
	cout << endl;
	int Key = 0, Result = 0;
	cout << "Введите искомое значение: "; cin >> Key;
	Result = BinarySearch(Array, Size, Key, Type);
	if (Result == Size)cout << "Искомый элемент не найден!" << endl;
	else cout << "Индекс искомого элемента равен: " << Result << endl;
}
//реализация шаблона функции "Быстрая сортировка"
template<typename T, typename L> void QuickSort_R(T Array[], L Size, bool Type)
{
	L i = 0, j = Size - 1; //счетчик i движется от начала последовательности, j от конца
	T temp = 0, cnt = Array[Size / 2]; //буфер и значение опорного элемента
	do
	{
		//пропускаем элементы, находящиеся на своих местах относительно опорного знаачения

		if (Type)
		{
			//от Мин. к Макс. по возрастанию
			while (Array[i] < cnt)i++; //пропуск элементов, чье значение меньше значения опорного элемента и слева от него
			while (Array[j] > cnt)j--; //пропуск элементов, чье значение больше значения опорного элемента и справа от него
		}
		else
		{
			//от Макс. к Мин. по возрастанию
			while (Array[i] > cnt)i++; //пропуск элементов, чье значение больше значения опорного элемента и слева от него
			while (Array[j] < cnt)j--; //пропуск элементов, чье значение меньше значения опорного элемента и справа от него
		}

		if (i <= j) //если счетчик не пересеклись
		{
			//меняем найденные элементы местами
			temp = Array[i];
			Array[i] = Array[j];
			Array[j] = temp;
			//исключаем перемещенные элементы
			i++;
			j--;
		}
	} while (i <= j); //до тех пор, пока счетчики не пересеклись

	//вызываем функцию для левой части массива, если остались неотсортированные элементы в левой части
	if (j > 0) QuickSort_R(Array, j + 1, Type); //j+1 кол-во элементов от начала последовательности, Array - адрес начала последовательности
	//вызываем функцию для правой части массива, если остались неотсортированные элементы в правой части
	if (i < Size) QuickSort_R(Array + i, Size - i, Type); //Size-i кол-во элементов до конца последовательности
	//Array+i смещение от адреса начала последовательности на i элементов
}
//реализация шаблона функции "Двоичный(Бинарный) поиск"
template<typename T, typename L> L BinarySearch(T Array[], L Size, T Key, bool Type)
{
	L cnt = 0, Begin = 0, End = Size;
	while (true) //бесконечный цикл
	{
		cnt = (Begin + End) / 2; //индекс опорного(центрального) элемента отрезка массива от Begin до End

		if (Type)
		{
			//Если массив отсортирован от Мин к Макс.
			//сравниваем искомое значение с значением опорного(центрального) элемента
			if (Key < Array[cnt])End = cnt - 1; //уменьшаем последовательность(переходим в левую часть)
			else if (Key > Array[cnt])Begin = cnt + 1; //уменьшаем последовательность(переходим в правую часть)
			else return cnt; //иначе элемент найден, возвращаем его индекс
		}
		else
		{
			//Если массив отсортирован от Макс. к Мин.
			//сравниваем искомое значение с значением опорного(центрального) элемента
			if (Key > Array[cnt])End = cnt - 1; //уменьшаем последовательность(переходим в левую часть)
			else if (Key < Array[cnt])Begin = cnt + 1; //уменьшаем последовательность(переходим в правую часть)
			else return cnt; //иначе элемент найден, возвращаем его индекс
		}

		if (Begin > End) //если счетчик пересеклись
			//return -1; //возрат в функция, с размером массива знакового типа данных(int, short, long long ...)
			return Size; //возврат размера массива для беззнаковых типов данных размера Size(unsigned int, unsigned short)
	}
}
