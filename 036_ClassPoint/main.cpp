// Point
#include <iostream>
#include <locale.h>

using namespace std;

//класс, описывающий точку в пространстве
class Point
{
    //private:
    int X, Y, Z;
public:
    //классический вариант, как у простого метода(функции)
    /*Point(int x, int y, int z)
    {
        X = x;
        Y = y;
        Z = z;
        cout<<"Конструктор с 3мя параметрами!"<<endl;
    }*/
    //конструктор с 3мя параметрами с унифицированной инициализацией полей
    Point(int x, int y, int z) : X{ x }, Y{ y }, Z{ z } { cout << "Конструктор с 3мя параметрами!" << endl; }
    //конструктор по умолчанию с унифицированной инициализацией полей
    //Point():X{},Y{},Z{}{cout<<"Конструктор по умолчанию!"<<endl;}
    //аналогично
    //Point() :X{0}, Y{0}, Z{0}{cout << "Конструктор по умолчанию!" << endl; }
    //конструктор с 2мя парамтерами и делегированием
    Point(int x, int z) : Point{ x,0,z } { cout << "Конструктор с 2мя параметрами и делегированием!" << endl; }
    //конструктор по умолчанию с делегированием конструктору с 3мя парамтерами
    Point() : Point{ 0,0,0 } { cout << "Конструктор по умолчанию c делегированием!" << endl; }
    //многкратное делегирование возможно, но не всегда имеет смылс
    //Point(): Point(0,0) {cout << "Конструктор по умолчанию c делегированием!" << endl;}

    //прототипы методов:
    //сеттеры
    //void SetX(int x);
    void SetX(int); //имена параметров можно не указывать
    void SetY(int); //отдельные сеттеры для каждого поля
    inline void SetZ(int); //просьба встроить метод внутрь класса(использовать только у прототипов)
    void SetPoint(int, int, int); //изменяет всю точку целиком

    //геттеры
    int GetX() const; //возвращает значение поля Х
    int GetY() const; //const - делает метод константным, то есть запрещает изменять содержимое полей
    int GetZ() const;
    //вывод на экран консоли
    void Show(); //для обычных объекта
    void Show()const //константная перегрузка метода Show для константных объектов
    {
        cout << "Константный метод Show!" << endl;
        cout << "(" << X << ";" << this->Y << ";" << GetZ() << ")" << endl;
    }
    //void Show(Point* const this);
    //void Show(const Point* const this){}
};

int main()
{
    setlocale(LC_ALL, "rus");
    Point A{ 10,20,30 }; //A - объект(экземпляр) класса Point, или A - переменная типа данных Point
    Point B;
    Point C(1, 2); //x=1, y=2, z=0 //если необходимо x=1,y=0,z=2

    //cout << sizeof(B) << endl;
    //cout << sizeof(Point) << endl;

    B.SetY(10);
    cout << "Адрес объекта B: " << &B << endl;
    B.Show();

    const float PI = 3.14F; //переменная с константным значением(переменная с модификатором const)
    //константа типа данных float

    const Point Z{ 3,4,5 }; //константный объект класса Point, содержимое его полей нельзя изменить после его создания
    //константа типа данных Point
    Z.Show();  //для константных объектов доступны только константные методы(с модификатором const)
    A.Show(); //для обычного объекта доступны все методы, вызывается неконстантный метод
}
//сеттеры
void Point::SetX(int x) //:: расширение области видимости или указание принадлежности(в данном случае классу Point)
{
    X = x;
}
void Point::SetY(int Y) //void Point::SetY(Point* const this, int Y)
{
    this->Y = Y; //this->Y обращение к полю Y того объекта для которого был вызван метод
    //cout << "Содержимое указателя this: " << this << endl; //this - хранит адрес объекта для которого вызван метод
}
inline void Point::SetZ(int z)
{
    Z = z; //this->Z = z; //с такой фразой работает компилятор
}
void Point::SetPoint(int x, int y, int z)
{
    //передача значений в поля объекта
    X = x; //напрямую в поле по имени поля
    this->Y = y; //обращение к имени поля через указатель this
    //SetZ(z); //вызов метода без привязки к объекту возможен только внутри метода или класса
    //метод SetZ получит тот же адрес(содержимое указателя this), будет вызван для текущего объекта,
    //для которого был вызван метод SetPoint()
    this->SetZ(z);   //SetZ(z); будет вызван через указатель this на объект для которого был вызван метод SetPoint
}
//геттеры
int Point::GetX() const //модификатор const указывает и в прототипе и в реализации
{
    return X;
}
int Point::GetY() const //модификатор const указывает и в прототипе и в реализации
{
    return Y;
}
int Point::GetZ() const //модификатор const указывает и в прототипе и в реализации
{
    //Z = 3; 
    //this->Z = 3; //все обращение к полям и метода происходит через указатель this
    //this->SetZ(3);
    //указатель this является константным Point* const this=&B;
    //в константном методе int Point::GetZ() const
    //указатель this становится константным указателем на константу const Point* const this=&B;
    return Z; //return this->Z; - так работает компилятор
}
//вывод на экран
void Point::Show()
{
    cout << "(" << X << ";" << this->Y << ";" << GetZ() << ")" << endl;
}
