// Class
#include <iostream>
#include <stdlib.h>

using namespace std;

//класс описывающий точку
class Point
{
    //private: //по умолчанию всё содержимое класса с модификатором(спицфикатором) доступа private
               //доступно только внутри самого класса, private можно не указывать
        //поля(свойства или члены) класса
    int X = 10; //задание значений полям по умолчанию
    int Y = 10; //эти значения будут использоваться конструктором по умолчанию(встариваемым компилятором)
public:  //разрешает доступ к содержимому класса из вне
    //конструктор - метод, вызываемый автоматически при создании объекта класса, должен быть public
    Point() //конструктор по умолчанию(без параметров), не возвращает результат
    {
        X = 0;
        Y = 0;
        cout << "Конструктор по умолчанию!" << endl;
    }
    Point(int x, int y) //конструктор с двумя параметрами
    {
        X = x;
        Y = y;
        cout << "Конструктор с параметрами!" << endl;
    }
    //деструктор - метод, который вызывается автоматически при уничтожении объекта
    ~Point() //деструктор в классе только один, не примает параметров и не возвращает результат
    {
        cout << "Сработал деструктор!" << endl;
    }
    //метод задания значений всем полям объекта
    void SetPoint(int x, int y) //set-функция(сеттер) //мутатор или модификатор
    {
        X = x;
        Y = y;
    }
    //метод получения значения поля Х
    int GetX()  //get-функция(геттер) //акссесор или инспектор
    {
        return X;
    }
    //метод получения значения поля Y
    int GetY()  //get-функция(геттер) //акссесор или инспектор
    {
        return Y;
    }
    //метод(функция-член) класса
    void Show() //
    {
        cout << "Координаты точки: (" << X << ";" << Y << ")" << endl;
    }
};

//структура Тест
struct Test
{
    int Temp1 = 0; //значения полей структуры по умолчанию
    int Temp2 = 0;
};
//функция вывода на экран
void Show(Test T)
{
    cout << T.Temp1 << " " << T.Temp2 << endl;
}

int main()
{
    system("chcp 1251");
    system("cls");
    //пустой объект структуры Тест
    //Test Object1;
    //cout << Object1.Temp1 << " " << Object1.Temp2 << endl;
    //Test Object2{ 3,15 }; //объект структуры с унифицированной инициализацией полей
    //Show(Object2);
    //Object1.Temp1 = -10;
    //Object1.Temp2 = 100;
    //Show(Object1);


    /*
    Point A; //создание объекта класса, конструктором по умолчанию
    //A.X = 100; //прямого доступа к полям объекта класса нет!
    A.Show(); //вызов метода для объекта класса

    Point B{}; //создание объекта класса с унифицированной инцииализацией, заполнит нулями,
    B.Show();  //если не указаны значения полей по умочланию и вызывает конструктором по умолчанию

    Point C{ 3,15 }; //вызывается конструктор с параметрами для объекта класса Point
    C.Show();

    int x = 0, y = 0;
    cout << "Введите координаты точки через пробел: " << endl;
    cin >> x >> y;
    Point D{ x,y }; //Point D(x,y); //так тоже можно
    D.Show();

    A.SetPoint(x, y); //вызов метода сеттера для изменения полей объекта
    A.Show();

    if (A.GetX()==D.GetX()&&A.GetY()==D.GetY())cout << "Точка А совпадает с точкой D!" << endl;
    cout<<"Координаты точки A ("<<A.GetX()<<";"<<A.GetY()<<")"<<endl;
    */

    /*
    Point Z; //вызывается конструктор по умолчаниюэ
    cout << "Адрес объекта Z: " << &Z << endl;
    cout << "Размер объекта Z: " << sizeof(Z)<< endl;
    Point* PTR = nullptr; //нулевой указатель на тип данных Point(указатель на объекты класса Point)
    PTR = &Z;
    PTR->Show(); //вызов метода через указатель на объект, с помощью оператора селектор ->
    PTR->SetPoint(5, -5);
    PTR->Show();
    system("cls");
    PTR = new Point; //динамическое выделение памяти под объекта класса Point, вызывается конструктор по умолчанию
    PTR->Show();
    PTR->SetPoint(15, -15);

    delete PTR; //оператор delete освобождает память и вызывает деструктор для объекта,
    PTR = nullptr; //хранещегося в динамически вызванной памяти

    //PTR = new Point(30, 40);
    PTR = new Point{ 30, 40 }; //динамическое выделение памяти под объекта класса Point, вызывается конструктор с параметрами
    PTR->Show();

    //PTR->~Point(); //явный вызов деструктора не уничтожает объект, крайне не рекомендуется

    delete PTR; //оператор delete освобождает память и вызывает деструктор для объекта,
    PTR = nullptr; //хранещегося в динамически вызванной памяти
    cout << "Память освобождена!" << endl;
    //Z.~Point(); //явный вызов деструктора не уничтожает объект, крайне не рекомендуется
    */


    int Size = 0;
    cout << "Введите кол-во точек: "; cin >> Size;
    //Point* Array = new Point[Size]; //будет вызван конструктор по умолчанию для каждого элемента массива
    //Point* Array = new Point[Size]{}; //будет вызван конструктор по умолчанию для каждого элемента массива
    //Point* Array = new Point[Size]{ {1,1},{2,2},{3,3} }; //вызов конструкторов с параметрами можно использовать только для статических массивов

    for (int i = 0; i < Size; i++)
    {
        Array[i].SetPoint(i + 1, i + 1); //для каждой точки(элемента массива) вызываем метод SetPoint
        Array[i].Show();
    }
    delete[] Array;
    Array = nullptr;

}

